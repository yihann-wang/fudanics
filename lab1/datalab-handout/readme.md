# CS:APP Data Lab 实验报告

本实验要求我们使用有限的 C 语言位操作来实现一系列具有特定功能的函数。这些限制要求我们深入理解二进制表示和位运算，通过巧妙的组合实现各种功能。

## 整数位操作函数

### 1. bitXor - 仅使用 ~ 和 & 实现异或 (^)

```c
int bitXor(int x, int y) {
  return ~(~x&~y)&~(x&y);
}
```

**思路**：要使用仅 ~ 和 & 实现异或操作，我利用了布尔代数的德摩根定律。
- 异或的定义是：当且仅当输入不同时输出为1
- 可以表达为：(x & ~y) | (~x & y)
- 使用德摩根定律：~(~(x & ~y) & ~(~x & y))
- 简化后得到：~(~x & ~y) & ~(x & y)

这个实现检查 x 和 y 在每个位上的关系，并正确地产生异或运算的结果。

### 2. tmin - 返回最小的二进制补码整数

```c
int tmin(void) {
  return 1<<31;
}
```

**思路**：在二进制补码表示中，最小的整数是 -2^31，其二进制表示为 0x80000000，即最高位为1，其余位为0。这可以通过将 1 左移 31 位实现。

### 3. isTmax - 判断是否为最大的二进制补码整数

```c
int isTmax(int x) {
  int i = x+1; // Tmin, 1000...
  x = x+i;     // -1, 1111...
  x = ~x;      // 0, 0000...
  i = !i;      // exclude x=0xffff...
  x = x+i;     // exclude x=0xffff...
  return !x;
}
```

**思路**：在二进制补码表示中，最大的整数是 2^31-1，其二进制表示为 0x7FFFFFFF。

关键观察：对于 Tmax (0x7FFFFFFF)，以下特性成立：
- Tmax + 1 = Tmin (0x80000000)
- Tmax + Tmin = -1 (所有位都是1)
- ~(-1) = 0

但是，这个特性也适用于 -1 (0xFFFFFFFF)，因为 -1 + 1 = 0，-1 + 0 = -1，~(-1) = 0。
因此，我需要排除 x = -1 这种情况，这是通过检查 i (即 x+1) 是否为 0 来实现的。

### 4. allOddBits - 判断所有奇数位是否都为1

```c
int allOddBits(int x) {
  int mask = 0xAA+(0xAA<<8);
  mask = mask+(mask<<16);
  return !((mask&x)^mask);
}
```

**思路**：要检查所有奇数位（位索引为1,3,5...）是否为1，我需要创建一个掩码，其奇数位全为1。

- 0xAA 在二进制中是 10101010，刚好奇数位为1
- 通过移位和加法扩展到整个32位整数：0xAAAAAAAA
- 用掩码与输入相与，如果结果等于掩码，则所有奇数位都是1
- 使用异或和逻辑非来判断是否相等

### 5. negate - 返回数的相反数

```c
int negate(int x) {
  return ~x+1;
}
```

**思路**：这是二进制补码表示的基本特性。一个数的相反数可以通过对其所有位取反然后加1得到。这源于二进制补码的设计，确保了 x + (-x) = 0。

### 6. isAsciiDigit - 判断是否为ASCII数字字符

```c
int isAsciiDigit(int x) {
  int sign = 0x1 << 31;          // 构造符号位掩码
  int upperBound = ~(sign | 0x39); // 构造上界
  int lowerBound = ~0x30;         // 构造下界
  upperBound = sign & (upperBound + x) >> 31; // 检查x是否小于等于上界
  lowerBound = sign & (lowerBound + 1 + x) >> 31; // 检查x是否大于等于下界
  return !(upperBound | lowerBound); // 判断x是否在范围内
}
```

**思路**：我需要检查 x 是否在范围 [0x30, 0x39] 内。在没有比较运算符的情况下，我使用了一个技巧：
- 利用二进制补码的溢出特性来判断大小关系
- 对于两个数 a 和 b，可以通过 (a + (~b + 1)) 的符号位来判断 a 是否小于等于 b
- 分别检查 x <= 0x39 和 x >= 0x30，然后结合两个结果

### 7. conditional - 实现条件表达式 x ? y : z

```c
int conditional(int x, int y, int z) {
  x = !!x;
  x = ~x+1;
  return (x&y)|(~x&z);
}
```

**思路**：要实现条件操作，我需要根据 x 的值创建一个全0或全1的掩码。
- 使用 !!x 将 x 规范化为 0 或 1
- 通过 ~x+1 将 0 转换为 0x00000000，将 1 转换为 0xFFFFFFFF
- 利用生成的掩码来选择 y 或 z：当 x 为真时选择 y，否则选择 z

### 8. isLessOrEqual - 判断 x <= y

```c
int isLessOrEqual(int x, int y) {
  int negX = ~x+1;      // -x
  int addX = negX+y;    // y-x
  int checkSign = addX>>31&1; // y-x的符号
  int leftBit = 1<<31;  // 最高位为1的32位有符号数
  int xLeft = x&leftBit; // x的符号
  int yLeft = y&leftBit; // y的符号
  int bitXor = xLeft ^ yLeft; // x和y符号相同标志位
  bitXor = (bitXor>>31)&1; // 符号相同标志位格式化为0或1
  return ((!bitXor)&(!checkSign))|(bitXor&(xLeft>>31));
}
```

**思路**：这道题需要考虑溢出情况。我分两种情况处理：
1. 当 x 和 y 符号相同时：直接比较 y-x 的符号位
2. 当 x 和 y 符号不同时：如果 x 为负，y 为正，则 x <= y 一定成立；反之不成立

算法步骤：
- 计算 y-x 并检查其符号
- 检查 x 和 y 的符号是否相同
- 根据符号情况分别处理并合并结果

### 9. logicalNeg - 不使用 ! 实现逻辑非运算

```c
int logicalNeg(int x) {
  return ((x|(~x+1))>>31)+1;
}
```

**思路**：判断一个数是否为0，可以利用以下特性：
- 对于非零数 x，x 和 -x (即 ~x+1) 中至少有一个是负数（符号位为1）
- 对于零，x 和 -x 都是0，符号位都是0
- 通过 (x | -x) >> 31 可以获得 -1（如果 x 非零）或 0（如果 x 为零）
- 加1后得到 0（非零）或 1（为零）

### 10. howManyBits - 返回表示 x 所需的最小位数

```c
int howManyBits(int x) {
  int b16,b8,b4,b2,b1,b0;
  int sign = x>>31;
  x = (sign&~x)|(~sign&x); // 如果x为正则不变，否则按位取反

  // 不断缩小范围
  b16 = !!(x>>16)<<4; // 高十六位是否有1
  x = x>>b16; // 如果有（至少需要16位），则将原数右移16位
  b8 = !!(x>>8)<<3; // 剩余位高8位是否有1
  x = x>>b8; // 如果有（至少需要16+8=24位），则右移8位
  b4 = !!(x>>4)<<2; // 同理
  x = x>>b4;
  b2 = !!(x>>2)<<1;
  x = x>>b2;
  b1 = !!(x>>1);
  x = x>>b1;
  b0 = x;
  return b16+b8+b4+b2+b1+b0+1; // +1表示加上符号位
}
```

**思路**：在二进制补码表示中，需要找到最高位的1的位置（对于正数）或最高位的0的位置（对于负数），再加上符号位。

算法采用二分查找的思想：
1. 对于负数，先按位取反，这样就转化为了求正数最高位1的问题
2. 使用二分查找思路，先检查高16位是否有1，如果有，则至少需要16位
3. 然后检查剩余位的高8位，依此类推
4. 最后将所有的位数加起来，再加上符号位

## 浮点数操作函数

### 11. floatScale2 - 返回浮点数 f 乘以2的结果

```c
unsigned floatScale2(unsigned uf) {
  int exp = (uf&0x7f800000)>>23;
  int sign = uf&(1<<31);
  if(exp==0) return uf<<1|sign;
  if(exp==255) return uf;
  exp++;
  if(exp==255) return 0x7f800000|sign;
  return (exp<<23)|(uf&0x807fffff);
}
```

**思路**：根据IEEE浮点数表示，乘以2有几种情况：
1. 对于非规格化数（exp=0）：直接将尾数左移一位，保留符号位
2. 对于规格化数：指数加1
3. 对于特殊值（NaN、无穷）：保持不变
4. 如果乘以2后溢出变成无穷：返回相应符号的无穷大

### 12. floatFloat2Int - 浮点数转整数

```c
int floatFloat2Int(unsigned uf) {
  int s_    = uf>>31;
  int exp_  = ((uf&0x7f800000)>>23)-127;
  int frac_ = (uf&0x007fffff)|0x00800000;
  if(!(uf&0x7fffffff)) return 0;

  if(exp_ > 31) return 0x80000000;
  if(exp_ < 0) return 0;

  if(exp_ > 23) frac_ <<= (exp_-23);
  else frac_ >>= (23-exp_);

  if(!((frac_>>31)^s_)) return frac_;
  else if(frac_>>31) return 0x80000000;
  else return ~frac_+1;
}
```

**思路**：浮点数转整数需要考虑多种情况：
1. 提取符号位、指数和尾数
2. 对于0，直接返回0
3. 对于超出范围的值（NaN、无穷、太大的数），返回0x80000000
4. 对于太小的数（小于1），返回0
5. 根据指数调整尾数的位置
6. 处理符号并返回最终结果

### 13. floatPower2 - 返回2的x次方的浮点表示

```c
unsigned floatPower2(int x) {
  x = x + 127;
  if (x < 0)
    return 0;
  return (x < 255) ? (x << 23) : 0x7f800000u;
}
```

**思路**：2的x次方在浮点表示中很特殊，尾数部分都是0，关键是指数部分：
1. 将x加上偏置值127得到指数字段
2. 如果指数太小（小于0），返回0
3. 如果指数在正常范围内，将指数左移23位作为浮点数表示
4. 如果指数太大，返回无穷大（0x7f800000）

## 总结

通过这个实验，我深入理解了二进制表示、位操作和IEEE浮点数标准。最有挑战性的部分是在受限的操作符集合下实现复杂的逻辑，这迫使我思考运算的本质并寻找巧妙的解决方案。特别是`howManyBits`和浮点数操作函数，它们要求我对二进制表示和IEEE浮点标准有深刻的理解。

这个实验帮助我提升了对计算机系统底层表示的理解，以及在位级别上进行思考和优化的能力，这对于系统编程和性能优化都是非常宝贵的技能。